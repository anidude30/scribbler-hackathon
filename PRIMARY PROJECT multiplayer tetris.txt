{
  "metadata": {
    "name": "New JSNB",
    "language_info": {
      "name": "JavaScipt",
      "version": "8.0"
    }
  },
  "jsnbversion": "v0.1",
  "cells": [
    {
      "code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Multiplayer Tetris</title>\n    <style>\n        body { display: flex; justify-content: center; }\n        canvas { background-color: #111; margin: 10px; }\n        .game-container { display: flex; flex-direction: column; align-items: center; }\n        h2 { color: white; }\n    </style>\n</head>\n<body>\n    <div class=\"game-container\">\n        <h2>Player 1 (WASD)</h2>\n        <canvas id=\"player1Canvas\" width=\"300\" height=\"600\"></canvas>\n    </div>\n    <div class=\"game-container\">\n        <h2>Player 2 (IJKL)</h2>\n        <canvas id=\"player2Canvas\" width=\"300\" height=\"600\"></canvas>\n    </div>\n    \n    <script src=\"tetris.js\"></script> <!-- Link to the external JavaScript file -->\n</body>\n</html>\n\n",
      "status": "",
      "output": "\n\n\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Multiplayer Tetris</title>\n    <style>\n        body { display: flex; justify-content: center; }\n        canvas { background-color: #111; margin: 10px; }\n        .game-container { display: flex; flex-direction: column; align-items: center; }\n        h2 { color: white; }\n    </style>\n\n\n    <div class=\"game-container\">\n        <h2>Player 1 (WASD)</h2>\n        <canvas id=\"player1Canvas\" width=\"300\" height=\"600\"></canvas>\n    </div>\n    <div class=\"game-container\">\n        <h2>Player 2 (IJKL)</h2>\n        <canvas id=\"player2Canvas\" width=\"300\" height=\"600\"></canvas>\n    </div>\n    \n    <script src=\"tetris.js\"></script> <!-- Link to the external JavaScript file -->\n\n\n\n",
      "type": "html"
    },
    {
      "code": "// Constants and Settings\nconst BLOCK_SIZE = 30;\nconst ROWS = 20;\nconst COLS = 10;\nconst COLORS = [\"#45FFCA\", \"#FFDDA1\", \"#FEFFAC\", \"#E68AFF\", \"#F1A3A3\", \"#FAE7FD\", \"#C7EAF1\"];\nconst SHAPES = [\n    [[1, 1, 0], [0, 1, 1]],               // 'S' shape\n    [[0, 1, 1], [1, 1, 0]],               // 'Z' shape\n    [[1, 1, 1, 1]],                       // 'I' shape\n    [[1, 1], [1, 1]],                     // 'O' shape\n    [[1, 0, 0], [1, 1, 1]],               // 'J' shape\n    [[0, 0, 1], [1, 1, 1]],               // 'L' shape\n    [[0, 1, 0], [1, 1, 1]]                // 'T' shape\n];\n\n// Draw a block on the canvas\nfunction drawBlock(ctx, x, y, color) {\n    ctx.fillStyle = color;\n    ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n    ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n}\n\n// Draw initial grid\nfunction drawGrid(ctx) {\n    for (let y = 0; y < ROWS; y++) {\n        for (let x = 0; x < COLS; x++) {\n            drawBlock(ctx, x, y, \"#111\");\n        }\n    }\n}\n\n// Piece Class Definition\nclass Piece {\n    constructor(canvas, shape, color) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext(\"2d\");\n        this.shape = shape;\n        this.color = color;\n        this.x = Math.floor(COLS / 2) - Math.ceil(shape[0].length / 2);\n        this.y = 0;\n    }\n\n    // Draw the piece on the grid\n    draw() {\n        this.shape.forEach((row, dy) => {\n            row.forEach((cell, dx) => {\n                if (cell) {\n                    drawBlock(this.ctx, this.x + dx, this.y + dy, this.color);\n                }\n            });\n        });\n    }\n\n    // Clear the piece's current position\n    clear() {\n        this.shape.forEach((row, dy) => {\n            row.forEach((cell, dx) => {\n                if (cell) {\n                    drawBlock(this.ctx, this.x + dx, this.y + dy, \"#111\");\n                }\n            });\n        });\n    }\n\n    // Move down and check for collision\n    moveDown() {\n        if (isValidMove(this, 0, 1)) {\n            this.clear();\n            this.y++;\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // Move left and check for boundary\n    moveLeft() {\n        if (isValidMove(this, -1, 0)) {\n            this.clear();\n            this.x--;\n            this.draw();\n        }\n    }\n\n    // Move right and check for boundary\n    moveRight() {\n        if (isValidMove(this, 1, 0)) {\n            this.clear();\n            this.x++;\n            this.draw();\n        }\n    }\n\n    // Rotate the piece and check if valid; revert if not\n    rotate() {\n        const originalShape = this.shape;\n        this.shape = this.shape[0].map((_, index) =>\n            this.shape.map(row => row[index]).reverse()\n        );\n\n        if (!isValidMove(this)) {\n            this.shape = originalShape; // Revert if rotation is invalid\n        } else {\n            this.clear();\n            this.draw();\n        }\n    }\n}\n\n// Grid for tracking filled cells\nlet grid1 = Array.from({ length: ROWS }, () => Array(COLS).fill(0));\nlet grid2 = Array.from({ length: ROWS }, () => Array(COLS).fill(0));\n\n// Check if piece position is valid\nfunction isValidMove(piece, offsetX = 0, offsetY = 0) {\n    const grid = piece.canvas === document.getElementById(\"player1Canvas\") ? grid1 : grid2;\n    return piece.shape.every((row, dy) =>\n        row.every((cell, dx) => {\n            if (!cell) return true;\n            const x = piece.x + dx + offsetX;\n            const y = piece.y + dy + offsetY;\n            return y >= 0 && y < ROWS && x >= 0 && x < COLS && !grid[y][x];\n        })\n    );\n}\n\n// Lock the piece in the grid and clear rows if needed\nfunction lockPiece(piece) {\n    const grid = piece.canvas === document.getElementById(\"player1Canvas\") ? grid1 : grid2;\n    piece.shape.forEach((row, dy) => {\n        row.forEach((cell, dx) => {\n            if (cell) {\n                const x = piece.x + dx;\n                const y = piece.y + dy;\n                grid[y][x] = piece.color;\n            }\n        });\n    });\n    clearRows(grid);\n}\n\n// Clear filled rows and update grid\nfunction clearRows(grid) {\n    grid = grid.filter(row => row.some(cell => !cell));\n    while (grid.length < ROWS) {\n        grid.unshift(Array(COLS).fill(0));\n    }\n}\n\nlet currentPiece1, currentPiece2;\nlet dropInterval = 1000;  // Time between automatic drops\nlet lastDropTime = Date.now();\n\n// Spawn a new piece\nfunction spawnPiece(player) {\n    const shapeIndex = Math.floor(Math.random() * SHAPES.length);\n    const shape = SHAPES[shapeIndex];\n    const color = COLORS[shapeIndex];\n    if (player === 1) {\n        currentPiece1 = new Piece(document.getElementById(\"player1Canvas\"), shape, color);\n    } else {\n        currentPiece2 = new Piece(document.getElementById(\"player2Canvas\"), shape, color);\n    }\n}\n\n// Game loop\nfunction gameLoop() {\n    const now = Date.now();\n    if (now - lastDropTime > dropInterval) {\n        if (!currentPiece1.moveDown()) {\n            lockPiece(currentPiece1);\n            spawnPiece(1);\n        }\n        if (!currentPiece2.moveDown()) {\n            lockPiece(currentPiece2);\n            spawnPiece(2);\n        }\n        lastDropTime = now;\n    }\n\n    requestAnimationFrame(gameLoop);\n}\n\n// Controls for moving and rotating the piece\ndocument.addEventListener(\"keydown\", event => {\n    if (currentPiece1) {\n        currentPiece1.clear();\n        if (event.key === \"a\") {\n            currentPiece1.moveLeft();\n        } else if (event.key === \"d\") {\n            currentPiece1.moveRight();\n        } else if (event.key === \"s\") {\n            currentPiece1.moveDown();\n        } else if (event.key === \"w\") {\n            currentPiece1.rotate();\n        }\n        currentPiece1.draw();\n    }\n\n    if (currentPiece2) {\n        currentPiece2.clear();\n        if (event.key === \"j\") {\n            currentPiece2.moveLeft();\n        } else if (event.key === \"l\") {\n            currentPiece2.moveRight();\n        } else if (event.key === \"k\") {\n            currentPiece2.moveDown();\n        } else if (event.key === \"i\") {\n            currentPiece2.rotate();\n        }\n        currentPiece2.draw();\n    }\n});\n\n// Start the game\ndrawGrid(document.getElementById(\"player1Canvas\").getContext(\"2d\"));\ndrawGrid(document.getElementById(\"player2Canvas\").getContext(\"2d\"));\nspawnPiece(1);\nspawnPiece(2);\ngameLoop();\n",
      "status": "[6]<br><span style=\"font-size:8px\">2ms<span></span></span>",
      "output": "",
      "type": "code"
    },
    {
      "code": "/*class Tetris {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext(\"2d\");\n        this.ctx.scale(30, 30);  // Scale to make the blocks larger\n        this.reset();\n        this.updateScore();\n    }\n\n    reset() {\n        // Initialize grid and other game variables\n        this.grid = Array.from({ length: 20 }, () => Array(10).fill(null));  // Grid initialized with null for empty cells\n        this.score = 0;\n        this.COLORS = [\n            \"#FF5733\",  // Red (for 'L' piece)\n            \"#33FF57\",  // Green (for 'Z' piece)\n            \"#3357FF\",  // Blue (for 'S' piece)\n            \"#FF33A1\",  // Pink (for 'T' piece)\n            \"#F1C40F\",  // Yellow (for 'O' piece)\n            \"#8E44AD\",  // Purple (for 'I' piece)\n            \"#3498DB\"   // Light Blue (for 'J' piece)\n        ];\n        this.piece = this.createPiece();\n        this.piecePos = { x: 3, y: 0 };\n        this.dropInterval = 500;  // Set drop interval in ms\n        this.lastDropTime = 0;\n    }\n\n    createPiece() {\n        const shapes = [\n            [[1, 1, 1, 1]],                  // 'I' shape\n            [[1, 1], [1, 1]],                // 'O' shape\n            [[1, 1, 0], [0, 1, 1]],          // 'S' shape\n            [[0, 1, 1], [1, 1, 0]],          // 'Z' shape\n            [[1, 1, 1], [0, 1, 0]],          // 'T' shape\n            [[1, 1, 1], [1, 0, 0]],          // 'L' shape\n            [[1, 1, 1], [0, 0, 1]]           // 'J' shape\n        ];\n        const randomShape = shapes[Math.floor(Math.random() * shapes.length)];\n        const randomColor = this.COLORS[Math.floor(Math.random() * this.COLORS.length)];\n        return { shape: randomShape, color: randomColor };\n    }\n\n    drawGrid() {\n        this.ctx.fillStyle = \"#111\";\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        this.grid.forEach((row, y) => {\n            row.forEach((color, x) => {\n                if (color) this.drawBlock(x, y, color);\n            });\n        });\n    }\n\n    drawBlock(x, y, color) {\n        this.ctx.fillStyle = color;\n        this.ctx.fillRect(x, y, 1, 1);\n        this.ctx.strokeRect(x, y, 1, 1);\n    }\n\n    drawPiece() {\n        this.piece.shape.forEach((row, dy) => {\n            row.forEach((value, dx) => {\n                if (value) this.drawBlock(this.piecePos.x + dx, this.piecePos.y + dy, this.piece.color);\n            });\n        });\n    }\n\n    mergePiece() {\n        this.piece.shape.forEach((row, dy) => {\n            row.forEach((value, dx) => {\n                if (value) {\n                    // Store the piece's color in the grid\n                    this.grid[this.piecePos.y + dy][this.piecePos.x + dx] = this.piece.color;\n                }\n            });\n        });\n    }\n\n    movePiece(offsetX) {\n        this.piecePos.x += offsetX;\n        if (this.collide()) this.piecePos.x -= offsetX;\n    }\n\n    dropPiece() {\n        this.piecePos.y++;\n        if (this.collide()) {\n            this.piecePos.y--;\n            this.mergePiece();\n            this.clearLines();\n            this.resetPiece();\n        }\n    }\n\n    rotatePiece() {\n        const originalShape = this.piece.shape;\n        this.piece.shape = this.piece.shape[0].map((_, i) => this.piece.shape.map(row => row[i])).reverse();\n        if (this.collide()) this.piece.shape = originalShape;\n    }\n\n    resetPiece() {\n        this.piece = this.createPiece();\n        this.piecePos = { x: 3, y: 0 };\n        if (this.collide()) this.reset();  // Reset if new piece collides at the top\n    }\n\n    clearLines() {\n        this.grid = this.grid.filter(row => row.some(cell => !cell));\n        const clearedLines = 20 - this.grid.length;\n        while (this.grid.length < 20) {\n            this.grid.unshift(Array(10).fill(null));  // Use null to represent empty cells\n        }\n        this.score += clearedLines * 10;\n        this.updateScore();\n    }\n\n    updateScore() {\n        this.canvas.previousElementSibling.innerText = \"Score: \" + this.score;\n    }\n\n    collide() {\n        return this.piece.shape.some((row, dy) => \n            row.some((value, dx) => \n                value && \n                (this.grid[this.piecePos.y + dy] && this.grid[this.piecePos.y + dy][this.piecePos.x + dx]) !== null\n            )\n        );\n    }\n\n    draw() {\n        this.drawGrid();\n        this.drawPiece();\n    }\n\n    update(time) {\n        if (time - this.lastDropTime > this.dropInterval) {\n            this.dropPiece();\n            this.lastDropTime = time;\n        }\n        this.draw();\n    }\n}\n\nconst player1 = new Tetris(document.getElementById(\"player1Canvas\"));\nconst player2 = new Tetris(document.getElementById(\"player2Canvas\"));\n\nfunction player1Controls(event) {\n    if (event.key === \"a\") player1.movePiece(-1);\n    if (event.key === \"d\") player1.movePiece(1);\n    if (event.key === \"s\") player1.dropPiece();\n    if (event.key === \"w\") player1.rotatePiece();\n    player1.draw();\n}\n\nfunction player2Controls(event) {\n    if (event.key === \"ArrowLeft\") player2.movePiece(-1);\n    if (event.key === \"ArrowRight\") player2.movePiece(1);\n    if (event.key === \"ArrowDown\") player2.dropPiece();\n    if (event.key === \"ArrowUp\") player2.rotatePiece();\n    player2.draw();\n}\n\ndocument.addEventListener(\"keydown\", event => {\n    player1Controls(event);\n    player2Controls(event);\n});\n\nfunction gameLoop(time = 0) {\n    player1.update(time);\n    player2.update(time);\n    requestAnimationFrame(gameLoop);\n}\n\ngameLoop();\n",
      "status": "[-]",
      "output": "<p class=\"error\">Invalid or unexpected token</p>",
      "type": "code"
    }
  ],
  "source": "https://github.com/gopi-suvanam/jsnb",
  "run_on_load": false
}