{
  "metadata": {
    "name": "Multiplayer Tetris",
    "language_info": {
      "name": "JavaScipt",
      "version": "8.0"
    }
  },
  "jsnbversion": "v0.1",
  "cells": [
    {
      "code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Multiplayer Tetris</title>\n    <style>\n        canvas { background-color: #111; display: block; margin: auto; }\n    </style>\n</head>\n<body>\n    <canvas id=\"tetrisCanvas\" width=\"300\" height=\"600\"></canvas>\n    <script src=\"tetris.js\"></script>\n</body>\n</html>\n",
      "status": "",
      "output": "\n\n\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Multiplayer Tetris</title>\n    <style>\n        canvas { background-color: #111; display: block; margin: auto; }\n    </style>\n\n\n    <canvas id=\"tetrisCanvas\" width=\"300\" height=\"600\"></canvas>\n    <script src=\"tetris.js\"></script>\n\n\n",
      "type": "html"
    },
    {
      "code": "/*<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Multiplayer Tetris</title>\n\n    <!-- Sound effects -->\n    <audio id=\"moveSound\" src=\"https://www.dropbox.com/scl/fi/yn1r3ctv8pivy9bgeu2i5/mixkit-bonus-earned-in-video-game-2058.wav?rlkey=nycfse6dh4g73lzff6t9y3x0e&st=57erueje&dl=0\"></audio>\n    <audio id=\"rotateSound\" src=\"https://www.dropbox.com/scl/fi/yn1r3ctv8pivy9bgeu2i5/mixkit-bonus-earned-in-video-game-2058.wav?rlkey=nycfse6dh4g73lzff6t9y3x0e&st=57erueje&dl=0\"></audio>\n    <audio id=\"cementSound\" src=\"https://www.dropbox.com/scl/fi/l8gh8b0u75v5dqmh9jnt9/mixkit-retro-game-notification-212.wav?rlkey=z65e5mperzcz3oqx1a720g8el&st=vzz4hq26&dl=0\"></audio>\n\n    <style>\n        canvas { background-color: #111; display: block; margin: auto; }\n    </style>\n</head>\n<body>\n    <canvas id=\"tetrisCanvas\" width=\"300\" height=\"600\"></canvas>\n    <script>\n        const canvas = document.getElementById(\"tetrisCanvas\");\n        const ctx = canvas.getContext(\"2d\");\n\n        // Sound elements\n        const moveSound = document.getElementById(\"moveSound\");\n        const rotateSound = document.getElementById(\"rotateSound\");\n        const cementSound = document.getElementById(\"cementSound\");\n\n        // Play sound utility function\n        function playSound(sound) {\n            sound.currentTime = 0;  // Reset sound to the beginning\n            sound.play();\n        }\n\n        // Variables for dynamic background gradient\n        let gradientShift = 0;\n\n        // Function to draw dynamic gradient background\n        function drawDynamicBackground() {\n            gradientShift += 0.01;  // Adjust this value to control the speed of color change\n\n            // Create a gradient that shifts over time\n            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);\n            gradient.addColorStop(0, hsl(${Math.sin(gradientShift) * 360}, 100%, 70%));\n            gradient.addColorStop(1, hsl(${(Math.sin(gradientShift + Math.PI) * 360)}, 100%, 70%));\n\n            // Fill the background with the gradient\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n\n        // Constants and Settings\n        const BLOCK_SIZE = 30;\n        const ROWS = 20;\n        const COLS = 10;\n        const COLORS = [\"#45FFCA\", \"#FFDDA1\", \"#FEFFAC\", \"#E68AFF\", \"#F1A3A3\", \"#FAE7FD\", \"#C7EAF1\"];\n\n        // Tetris shapes\n        const SHAPES = [\n            [[1, 1, 0], [0, 1, 1]],               // 'S' shape\n            [[0, 1, 1], [1, 1, 0]],               // 'Z' shape\n            [[1, 1, 1, 1]],                       // 'I' shape\n            [[1, 1], [1, 1]],                     // 'O' shape\n            [[1, 0, 0], [1, 1, 1]],               // 'J' shape\n            [[0, 0, 1], [1, 1, 1]],               // 'L' shape\n            [[0, 1, 0], [1, 1, 1]]                // 'T' shape\n        ];\n\n        // Draw a block on the canvas\n        function drawBlock(x, y, color) {\n            ctx.fillStyle = color;\n            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n        }\n\n        // Draw initial grid\n        function drawGrid() {\n            for (let y = 0; y < ROWS; y++) {\n                for (let x = 0; x < COLS; x++) {\n                    drawBlock(x, y, \"#111\");\n                }\n            }\n        }\n\n        // Piece Class Definition\n        class Piece {\n            constructor(shape, color) {\n                this.shape = shape;\n                this.color = color;\n                this.x = Math.floor(COLS / 2) - Math.ceil(shape[0].length / 2);\n                this.y = 0;\n            }\n\n            // Draw the piece on the grid\n            draw() {\n                this.shape.forEach((row, dy) => {\n                    row.forEach((cell, dx) => {\n                        if (cell) {\n                            drawBlock(this.x + dx, this.y + dy, this.color);\n                        }\n                    });\n                });\n            }\n\n            // Clear the piece's current position\n            clear() {\n                this.shape.forEach((row, dy) => {\n                    row.forEach((cell, dx) => {\n                        if (cell) {\n                            drawBlock(this.x + dx, this.y + dy, \"#111\");\n                        }\n                    });\n                });\n            }\n\n            // Move down and check for collision\n            moveDown() {\n                if (isValidMove(this, 0, 1)) {\n                    this.clear();\n                    this.y++;\n                    this.draw();\n                    return true;\n                }\n                return false;\n            }\n\n            // Move left and play sound\n            moveLeft() {\n                if (isValidMove(this, -1, 0)) {\n                    this.clear();\n                    this.x--;\n                    playSound(moveSound);  // Play move sound\n                    this.draw();\n                }\n            }\n\n            // Move right and play sound\n            moveRight() {\n                if (isValidMove(this, 1, 0)) {\n                    this.clear();\n                    this.x++;\n                    playSound(moveSound);  // Play move sound\n                    this.draw();\n                }\n            }\n\n            // Rotate the piece and play sound if valid\n            rotate() {\n                const originalShape = this.shape;\n                this.shape = this.shape[0].map((_, index) =>\n                    this.shape.map(row => row[index]).reverse()\n                );\n\n                if (!isValidMove(this)) {\n                    this.shape = originalShape; // Revert if rotation is invalid\n                } else {\n                    this.clear();\n                    playSound(rotateSound);  // Play rotate sound\n                    this.draw();\n                }\n            }\n        }\n\n        // Grid for tracking filled cells\n        let grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));\n\n        // Check if piece position is valid\n        function isValidMove(piece, offsetX = 0, offsetY = 0) {\n            return piece.shape.every((row, dy) =>\n                row.every((cell, dx) => {\n                    if (!cell) return true;\n                    const x = piece.x + dx + offsetX;\n                    const y = piece.y + dy + offsetY;\n                    return y >= 0 && y < ROWS && x >= 0 && x < COLS && !grid[y][x];\n                })\n            );\n        }\n\n        // Lock the piece in the grid, clear rows, and play cement sound\n        function lockPiece(piece) {\n            piece.shape.forEach((row, dy) => {\n                row.forEach((cell, dx) => {\n                    if (cell) {\n                        const x = piece.x + dx;\n                        const y = piece.y + dy;\n                        grid[y][x] = piece.color;\n                    }\n                });\n            });\n            clearRows();\n            \n            // Play cement sound when a piece locks in place\n            playSound(cementSound);\n        }\n\n        // Clear filled rows and update grid\n        function clearRows() {\n            grid = grid.filter(row => row.some(cell => !cell));\n            while (grid.length < ROWS) {\n                grid.unshift(Array(COLS).fill(0));\n            }\n        }\n\n        let currentPiece;\n        let dropInterval = 1000;  // Time between automatic drops\n        let lastDropTime = Date.now();\n\n        // Spawn a new piece\n        function spawnPiece() {\n            const shapeIndex = Math.floor(Math.random() * SHAPES.length);\n            currentPiece = new Piece(SHAPES[shapeIndex], COLORS[shapeIndex]);\n        }\n\n        // Game loop\n        function gameLoop() {\n            drawDynamicBackground();  // Draw the dynamic background at the start of each loop\n            const now = Date.now();\n            if (now - lastDropTime > dropInterval) {\n                if (!currentPiece.moveDown()) {\n                    lockPiece(currentPiece);\n                    spawnPiece();\n                }\n                lastDropTime = now;\n            }\n\n            requestAnimationFrame(gameLoop);\n        }\n\n        // Controls for moving and rotating the piece\n        document.addEventListener(\"keydown\", event => {\n            if (currentPiece) {\n                currentPiece.clear();\n                if (event.key === \"ArrowLeft\") {\n                    currentPiece.moveLeft();\n                } else if (event.key === \"ArrowRight\") {\n                    currentPiece.moveRight();\n                } else if (event.key === \"ArrowDown\") {\n                    currentPiece.moveDown();\n                } else if (event.key === \"ArrowUp\") {\n                    currentPiece.rotate();\n                }\n                currentPiece.draw();\n            }\n        });\n\n        // Start the game\n        drawGrid();\n        spawnPiece();\n        gameLoop();\n    </script>\n</body>\n</html>",
      "status": "",
      "output": "/*\n\n\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Multiplayer Tetris</title>\n\n    <!-- Sound effects -->\n    <audio id=\"moveSound\" src=\"https://www.dropbox.com/scl/fi/yn1r3ctv8pivy9bgeu2i5/mixkit-bonus-earned-in-video-game-2058.wav?rlkey=nycfse6dh4g73lzff6t9y3x0e&amp;st=57erueje&amp;dl=0\"></audio>\n    <audio id=\"rotateSound\" src=\"https://www.dropbox.com/scl/fi/yn1r3ctv8pivy9bgeu2i5/mixkit-bonus-earned-in-video-game-2058.wav?rlkey=nycfse6dh4g73lzff6t9y3x0e&amp;st=57erueje&amp;dl=0\"></audio>\n    <audio id=\"cementSound\" src=\"https://www.dropbox.com/scl/fi/l8gh8b0u75v5dqmh9jnt9/mixkit-retro-game-notification-212.wav?rlkey=z65e5mperzcz3oqx1a720g8el&amp;st=vzz4hq26&amp;dl=0\"></audio>\n\n    <style>\n        canvas { background-color: #111; display: block; margin: auto; }\n    </style>\n\n\n    <canvas id=\"tetrisCanvas\" width=\"300\" height=\"600\"></canvas>\n    <script>\n        const canvas = document.getElementById(\"tetrisCanvas\");\n        const ctx = canvas.getContext(\"2d\");\n\n        // Sound elements\n        const moveSound = document.getElementById(\"moveSound\");\n        const rotateSound = document.getElementById(\"rotateSound\");\n        const cementSound = document.getElementById(\"cementSound\");\n\n        // Play sound utility function\n        function playSound(sound) {\n            sound.currentTime = 0;  // Reset sound to the beginning\n            sound.play();\n        }\n\n        // Variables for dynamic background gradient\n        let gradientShift = 0;\n\n        // Function to draw dynamic gradient background\n        function drawDynamicBackground() {\n            gradientShift += 0.01;  // Adjust this value to control the speed of color change\n\n            // Create a gradient that shifts over time\n            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);\n            gradient.addColorStop(0, hsl(${Math.sin(gradientShift) * 360}, 100%, 70%));\n            gradient.addColorStop(1, hsl(${(Math.sin(gradientShift + Math.PI) * 360)}, 100%, 70%));\n\n            // Fill the background with the gradient\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n\n        // Constants and Settings\n        const BLOCK_SIZE = 30;\n        const ROWS = 20;\n        const COLS = 10;\n        const COLORS = [\"#45FFCA\", \"#FFDDA1\", \"#FEFFAC\", \"#E68AFF\", \"#F1A3A3\", \"#FAE7FD\", \"#C7EAF1\"];\n\n        // Tetris shapes\n        const SHAPES = [\n            [[1, 1, 0], [0, 1, 1]],               // 'S' shape\n            [[0, 1, 1], [1, 1, 0]],               // 'Z' shape\n            [[1, 1, 1, 1]],                       // 'I' shape\n            [[1, 1], [1, 1]],                     // 'O' shape\n            [[1, 0, 0], [1, 1, 1]],               // 'J' shape\n            [[0, 0, 1], [1, 1, 1]],               // 'L' shape\n            [[0, 1, 0], [1, 1, 1]]                // 'T' shape\n        ];\n\n        // Draw a block on the canvas\n        function drawBlock(x, y, color) {\n            ctx.fillStyle = color;\n            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n        }\n\n        // Draw initial grid\n        function drawGrid() {\n            for (let y = 0; y < ROWS; y++) {\n                for (let x = 0; x < COLS; x++) {\n                    drawBlock(x, y, \"#111\");\n                }\n            }\n        }\n\n        // Piece Class Definition\n        class Piece {\n            constructor(shape, color) {\n                this.shape = shape;\n                this.color = color;\n                this.x = Math.floor(COLS / 2) - Math.ceil(shape[0].length / 2);\n                this.y = 0;\n            }\n\n            // Draw the piece on the grid\n            draw() {\n                this.shape.forEach((row, dy) => {\n                    row.forEach((cell, dx) => {\n                        if (cell) {\n                            drawBlock(this.x + dx, this.y + dy, this.color);\n                        }\n                    });\n                });\n            }\n\n            // Clear the piece's current position\n            clear() {\n                this.shape.forEach((row, dy) => {\n                    row.forEach((cell, dx) => {\n                        if (cell) {\n                            drawBlock(this.x + dx, this.y + dy, \"#111\");\n                        }\n                    });\n                });\n            }\n\n            // Move down and check for collision\n            moveDown() {\n                if (isValidMove(this, 0, 1)) {\n                    this.clear();\n                    this.y++;\n                    this.draw();\n                    return true;\n                }\n                return false;\n            }\n\n            // Move left and play sound\n            moveLeft() {\n                if (isValidMove(this, -1, 0)) {\n                    this.clear();\n                    this.x--;\n                    playSound(moveSound);  // Play move sound\n                    this.draw();\n                }\n            }\n\n            // Move right and play sound\n            moveRight() {\n                if (isValidMove(this, 1, 0)) {\n                    this.clear();\n                    this.x++;\n                    playSound(moveSound);  // Play move sound\n                    this.draw();\n                }\n            }\n\n            // Rotate the piece and play sound if valid\n            rotate() {\n                const originalShape = this.shape;\n                this.shape = this.shape[0].map((_, index) =>\n                    this.shape.map(row => row[index]).reverse()\n                );\n\n                if (!isValidMove(this)) {\n                    this.shape = originalShape; // Revert if rotation is invalid\n                } else {\n                    this.clear();\n                    playSound(rotateSound);  // Play rotate sound\n                    this.draw();\n                }\n            }\n        }\n\n        // Grid for tracking filled cells\n        let grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));\n\n        // Check if piece position is valid\n        function isValidMove(piece, offsetX = 0, offsetY = 0) {\n            return piece.shape.every((row, dy) =>\n                row.every((cell, dx) => {\n                    if (!cell) return true;\n                    const x = piece.x + dx + offsetX;\n                    const y = piece.y + dy + offsetY;\n                    return y >= 0 && y < ROWS && x >= 0 && x < COLS && !grid[y][x];\n                })\n            );\n        }\n\n        // Lock the piece in the grid, clear rows, and play cement sound\n        function lockPiece(piece) {\n            piece.shape.forEach((row, dy) => {\n                row.forEach((cell, dx) => {\n                    if (cell) {\n                        const x = piece.x + dx;\n                        const y = piece.y + dy;\n                        grid[y][x] = piece.color;\n                    }\n                });\n            });\n            clearRows();\n            \n            // Play cement sound when a piece locks in place\n            playSound(cementSound);\n        }\n\n        // Clear filled rows and update grid\n        function clearRows() {\n            grid = grid.filter(row => row.some(cell => !cell));\n            while (grid.length < ROWS) {\n                grid.unshift(Array(COLS).fill(0));\n            }\n        }\n\n        let currentPiece;\n        let dropInterval = 1000;  // Time between automatic drops\n        let lastDropTime = Date.now();\n\n        // Spawn a new piece\n        function spawnPiece() {\n            const shapeIndex = Math.floor(Math.random() * SHAPES.length);\n            currentPiece = new Piece(SHAPES[shapeIndex], COLORS[shapeIndex]);\n        }\n\n        // Game loop\n        function gameLoop() {\n            drawDynamicBackground();  // Draw the dynamic background at the start of each loop\n            const now = Date.now();\n            if (now - lastDropTime > dropInterval) {\n                if (!currentPiece.moveDown()) {\n                    lockPiece(currentPiece);\n                    spawnPiece();\n                }\n                lastDropTime = now;\n            }\n\n            requestAnimationFrame(gameLoop);\n        }\n\n        // Controls for moving and rotating the piece\n        document.addEventListener(\"keydown\", event => {\n            if (currentPiece) {\n                currentPiece.clear();\n                if (event.key === \"ArrowLeft\") {\n                    currentPiece.moveLeft();\n                } else if (event.key === \"ArrowRight\") {\n                    currentPiece.moveRight();\n                } else if (event.key === \"ArrowDown\") {\n                    currentPiece.moveDown();\n                } else if (event.key === \"ArrowUp\") {\n                    currentPiece.rotate();\n                }\n                currentPiece.draw();\n            }\n        });\n\n        // Start the game\n        drawGrid();\n        spawnPiece();\n        gameLoop();\n    </script>\n\n",
      "type": "html"
    },
    {
      "code": "const canvas = document.getElementById(\"tetrisCanvas\");\nconst ctx = canvas.getContext(\"2d\");\n\n// Constants and Settings\nconst BLOCK_SIZE = 30;\nconst ROWS = 20;\nconst COLS = 10;\nconst COLORS = [\"#45FFCA\", \"#FFDDA1\", \"#FEFFAC\", \"#E68AFF\", \"#F1A3A3\", \"#FAE7FD\", \"#C7EAF1\"];\n\n// Tetris shapes\nconst SHAPES = [\n    [[1, 1, 0], [0, 1, 1]],               // 'S' shape\n    [[0, 1, 1], [1, 1, 0]],               // 'Z' shape\n    [[1, 1, 1, 1]],                       // 'I' shape\n    [[1, 1], [1, 1]],                     // 'O' shape\n    [[1, 0, 0], [1, 1, 1]],               // 'J' shape\n    [[0, 0, 1], [1, 1, 1]],               // 'L' shape\n    [[0, 1, 0], [1, 1, 1]]                // 'T' shape\n];\n\n// Draw a block on the canvas\nfunction drawBlock(x, y, color) {\n    ctx.fillStyle = color;\n    ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n    ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);\n}\n\n// Draw initial grid\nfunction drawGrid() {\n    for (let y = 0; y < ROWS; y++) {\n        for (let x = 0; x < COLS; x++) {\n            drawBlock(x, y, \"#111\");\n        }\n    }\n}\n\n// Piece Class Definition\nclass Piece {\n    constructor(shape, color) {\n        this.shape = shape;\n        this.color = color;\n        this.x = Math.floor(COLS / 2) - Math.ceil(shape[0].length / 2);\n        this.y = 0;\n    }\n\n    // Draw the piece on the grid\n    draw() {\n        this.shape.forEach((row, dy) => {\n            row.forEach((cell, dx) => {\n                if (cell) {\n                    drawBlock(this.x + dx, this.y + dy, this.color);\n                }\n            });\n        });\n    }\n\n    // Clear the piece's current position\n    clear() {\n        this.shape.forEach((row, dy) => {\n            row.forEach((cell, dx) => {\n                if (cell) {\n                    drawBlock(this.x + dx, this.y + dy, \"#111\");\n                }\n            });\n        });\n    }\n\n    // Move down and check for collision\n    moveDown() {\n        if (isValidMove(this, 0, 1)) {\n            this.clear();\n            this.y++;\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // Move left and check for boundary\n    moveLeft() {\n        if (isValidMove(this, -1, 0)) {\n            this.clear();\n            this.x--;\n            this.draw();\n        }\n    }\n\n    // Move right and check for boundary\n    moveRight() {\n        if (isValidMove(this, 1, 0)) {\n            this.clear();\n            this.x++;\n            this.draw();\n        }\n    }\n\n    // Rotate the piece and check if valid; revert if not\n    rotate() {\n        const originalShape = this.shape;\n        this.shape = this.shape[0].map((_, index) =>\n            this.shape.map(row => row[index]).reverse()\n        );\n\n        if (!isValidMove(this)) {\n            this.shape = originalShape; // Revert if rotation is invalid\n        } else {\n            this.clear();\n            this.draw();\n        }\n    }\n}\n\n// Grid for tracking filled cells\nlet grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));\n\n// Check if piece position is valid\nfunction isValidMove(piece, offsetX = 0, offsetY = 0) {\n    return piece.shape.every((row, dy) =>\n        row.every((cell, dx) => {\n            if (!cell) return true;\n            const x = piece.x + dx + offsetX;\n            const y = piece.y + dy + offsetY;\n            return y >= 0 && y < ROWS && x >= 0 && x < COLS && !grid[y][x];\n        })\n    );\n}\n\n// Lock the piece in the grid and clear rows if needed\nfunction lockPiece(piece) {\n    piece.shape.forEach((row, dy) => {\n        row.forEach((cell, dx) => {\n            if (cell) {\n                const x = piece.x + dx;\n                const y = piece.y + dy;\n                grid[y][x] = piece.color;\n            }\n        });\n    });\n    clearRows();\n}\n\n// Clear filled rows and update grid\nfunction clearRows() {\n    grid = grid.filter(row => row.some(cell => !cell));\n    while (grid.length < ROWS) {\n        grid.unshift(Array(COLS).fill(0));\n    }\n}\n\nlet currentPiece;\nlet dropInterval = 1000;  // Time between automatic drops\nlet lastDropTime = Date.now();\n\n// Spawn a new piece\nfunction spawnPiece() {\n    const shapeIndex = Math.floor(Math.random() * SHAPES.length);\n    currentPiece = new Piece(SHAPES[shapeIndex], COLORS[shapeIndex]);\n}\n\n// Game loop\nfunction gameLoop() {\n    const now = Date.now();\n    if (now - lastDropTime > dropInterval) {\n        if (!currentPiece.moveDown()) {\n            lockPiece(currentPiece);\n            spawnPiece();\n        }\n        lastDropTime = now;\n    }\n\n    requestAnimationFrame(gameLoop);\n}\n\n// Controls for moving and rotating the piece\ndocument.addEventListener(\"keydown\", event => {\n    if (currentPiece) {\n        currentPiece.clear();\n        if (event.key === \"ArrowLeft\") {\n            currentPiece.moveLeft();\n        } else if (event.key === \"ArrowRight\") {\n            currentPiece.moveRight();\n        } else if (event.key === \"ArrowDown\") {\n            currentPiece.moveDown();\n        } else if (event.key === \"ArrowUp\") {\n            currentPiece.rotate();\n        }\n        currentPiece.draw();\n    }\n});\n\n// Start the game\ndrawGrid();\nspawnPiece();\ngameLoop();\n",
      "status": "[5]<br><span style=\"font-size:8px\">0ms<span></span></span>",
      "output": "",
      "type": "code"
    }
  ],
  "source": "https://github.com/gopi-suvanam/jsnb",
  "run_on_load": false
}